<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.121.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="数据结构基础之树"><meta itemprop=description content="tree-of-datastructure"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/img/avatar.jpg"><meta itemprop=keywords content="数据结构"><meta property="og:type" content="article"><meta property="og:title" content="数据结构基础之树"><meta property="og:description" content="tree-of-datastructure"><meta property="og:image" content="/img/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/tree-of-datastructure/"><meta property="og:site_name" content="Patrick's Blog"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Patrick"><meta property="article:published_time" content="2017-11-18 12:34:41 +0800 CST"><meta property="article:modified_time" content="2024-04-04 09:21:51 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.a987c3fbca3727259a25c99140afed885cbffe7b77dba717d89bbe0780afcd01.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"css":{"file":"dist/katex.min.css","name":"katex","version":"0.16.0"},"js":[{"file":"dist/katex.min.js","name":"katex","version":"0.16.0"},{"alias_name":"katex","file":"dist/contrib/auto-render.min.js","name":"auto-render","version":"0.16.0"}],"render":"katex"},"path":"tree-of-datastructure","permalink":"/post/tree-of-datastructure/","title":"数据结构基础之树","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>数据结构基础之树 - Patrick's Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Patrick's Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Once start, goes forward!</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>33</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#结点分类>结点分类</a><ul><li><a href=#相关概念>相关概念</a></li></ul></li><li><a href=#抽象数据类型定义>抽象数据类型定义</a></li><li><a href=#存储结构>存储结构</a><ul><li><a href=#双亲表示法>双亲表示法</a></li><li><a href=#孩子表示法>孩子表示法</a><ul><li><a href=#结构>结构:</a></li><li><a href=#扩展>扩展</a></li></ul></li><li><a href=#孩子兄弟表示法>孩子兄弟表示法</a></li></ul></li><li><a href=#二叉树binary-tree>二叉树(Binary Tree)</a><ul><li><a href=#特殊二叉树>特殊二叉树</a><ul><li><a href=#完全二叉树>完全二叉树:</a></li></ul></li><li><a href=#二叉树的性质>二叉树的性质</a><ul><li><a href=#性质一>性质一:</a></li><li><a href=#性质二>性质二:</a></li><li><a href=#性质三>性质三:</a></li><li><a href=#性质四>性质四:</a></li><li><a href=#性质五>性质五:</a></li></ul></li><li><a href=#二叉树的存储结构>二叉树的存储结构</a><ul><li><a href=#二叉树顺序存储结构>二叉树顺序存储结构</a></li><li><a href=#二叉链表>二叉链表</a></li></ul></li><li><a href=#遍历二叉树>遍历二叉树</a><ul><li><a href=#前序遍历递归算法>前序遍历递归算法</a></li><li><a href=#中序遍历递归算法684>中序遍历递归算法(6.8.4)</a></li><li><a href=#后序遍历递归算法>后序遍历递归算法</a></li><li><a href=#遍历总结>遍历总结</a></li><li><a href=#遍历性质>遍历性质</a></li></ul></li><li><a href=#二叉树的建立>二叉树的建立</a></li><li><a href=#线索二叉树threaded-binary-tree>线索二叉树(Threaded Binary Tree)</a><ul><li><a href=#使用场景>使用场景</a></li></ul></li></ul></li><li><a href=#霍夫曼树huffman-tree>霍夫曼树(Huffman Tree)</a><ul><li><a href=#算法描述>算法描述</a></li><li><a href=#霍夫曼编码>霍夫曼编码</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Patrick src=/imgs/img-lazy-loading.gif data-src=/img/avatar.jpg><p class=site-author-name itemprop=name>Patrick</p><div class=site-description itemprop=description>个人学习笔记</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>33</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>8</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2015-04-05T13:57:58+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=22332></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=121></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-05-31T21:26:21+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/tree-of-datastructure/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/img/avatar.jpg"><meta itemprop=name content="Patrick"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Patrick"><meta itemprop=description content="个人学习笔记"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="数据结构基础之树"><meta itemprop=description content="tree-of-datastructure"></span><header class=post-header><h1 class=post-title itemprop="name headline">数据结构基础之树
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/tree-of-datastructure.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2017-11-18 12:34:41 +0800 CST" itemprop="dateCreated datePublished" datetime="2017-11-18 12:34:41 +0800 CST">2017-11-18
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-04-04T09:21:51+08:00 itemprop=dateModified datetime=2024-04-04T09:21:51+08:00>2024-04-04</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95 itemprop=url rel=index><span itemprop=name>数据结构与算法</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>430</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>3分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/tree-of-datastructure/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=简介>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b></a></h2><ul><li>概念: 为n(n>=0)个结点的有限集。n=0时为空树。</li><li>特点: 在任意一棵非空树中<ul><li>有且仅有一个特定的称为根(Root)的结点</li><li>当n>1时, 其余结点可以分为m(m>0)个互不相交的有限集T1、T2、&mldr;&mldr;、Tm, 其中每一个集合本身又是一棵树, 并且称为根的子树(SubTree)</li></ul></li></ul><h2 id=结点分类>结点分类
<a class=header-anchor href=#%e7%bb%93%e7%82%b9%e5%88%86%e7%b1%bb></a></h2><ul><li>根结点: 无双亲, 唯一</li><li>叶结点: 无孩子, 可以多个</li><li>中间结点: 一个双亲多个孩子</li></ul><h3 id=相关概念>相关概念
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5></a></h3><ul><li>度:<ul><li>结点拥有的子树数, 度为零的结点称为叶结点或终端结点, 度不为零的结点称为非终端结点或分支结点</li></ul></li><li>树的度:<ul><li>树内各节点的度的最大值</li></ul></li><li>结点的层次:<ul><li>从根开始定义起, 根为第一层, 根的孩子为第二层</li></ul></li><li>树的深度或高度:<ul><li>树中结点的最大层次</li></ul></li><li>有序树和无序树:<ul><li>如果将树中结点的各子树看成从左至右是有次序的, 不能互换的, 则称该树为有序树, 否则称为无序树</li></ul></li><li>森林:<ul><li>m(m>=0)棵互不相交的树的集合, 对树中每个结点而言, 其子树的集合即为森林</li></ul></li></ul><h2 id=抽象数据类型定义>抽象数据类型定义
<a class=header-anchor href=#%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89></a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>ADT 树(tree)
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>	由一个根节点和若干棵子树构成。树中结点具有相同数据类型及层次关系
</span></span><span style=display:flex><span>Operation
</span></span><span style=display:flex><span>    InitTree(*T): 构造空树
</span></span><span style=display:flex><span>    DestroyTree(*T): 销毁树
</span></span><span style=display:flex><span>    CreateTree(*T, definition): 按definition中给出树的定义来构造树
</span></span><span style=display:flex><span>    ClearTree(*T): 若树T存在, 则将树T清为空树
</span></span><span style=display:flex><span>    TreeEmpty(T): 若T为空树, 返回true, 否则返回false
</span></span><span style=display:flex><span>    TreeDepth(T): 返回T的深度
</span></span><span style=display:flex><span>    Root(T): 返回T的根结点
</span></span><span style=display:flex><span>    Value(T,cur_e): cur_e是树T中一个结点, 返回此结点的值
</span></span><span style=display:flex><span>    Assign(T,cur_e,value): 给树T的结点cur_e赋值为value
</span></span><span style=display:flex><span>    Parent(T,cur_e): 若cur_e是树T的非根结点, 则返回它的双亲, 否则返回空
</span></span><span style=display:flex><span>    LeftChild(T,cur_e): 若cur_e是树T的非叶结点, 则返回它的最左孩子, 否则返回空
</span></span><span style=display:flex><span>    RightSibling(T,cur_e): 若cur_e有右兄弟, 则返回它的右兄弟, 否则返回空
</span></span><span style=display:flex><span>    InsertChild(*T,*p,i,c): 其中p指向树T的某个结点, i为所指结点p的度加上1, 非空树c与T不相交, 操作结果为插入c为树T中p指结点的第i棵子树
</span></span><span style=display:flex><span>    DeleteChild(*T,*p,i): 其中p指向树T的某个结点, i为所指结点p的度, 操作结果为删除T中p所指结点的第i课子树
</span></span><span style=display:flex><span>end ADT
</span></span></code></pre></div><h2 id=存储结构>存储结构
<a class=header-anchor href=#%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84></a></h2><h3 id=双亲表示法>双亲表示法
<a class=header-anchor href=#%e5%8f%8c%e4%ba%b2%e8%a1%a8%e7%a4%ba%e6%b3%95></a></h3><ul><li>说明:<ul><li>data为数据域, parent为指针域, 根结点的位置域设置为-1</li></ul></li><li>双亲域表示法<table><thead><tr><th>下标</th><th>data</th><th>parent</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>1</td></tr><tr><td>4</td><td>E</td><td>2</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>G</td><td>3</td></tr><tr><td>7</td><td>H</td><td>3</td></tr><tr><td>8</td><td>I</td><td>3</td></tr><tr><td>9</td><td>J</td><td>4</td></tr></tbody></table></li><li>长子域表示法</li><li>右兄弟域表示法</li></ul><h3 id=孩子表示法>孩子表示法
<a class=header-anchor href=#%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95></a></h3><ul><li>引入:<ul><li>采用多重链表: 每个结点有多个指针域, 其中每个指针指向一棵树的根节点</li><li>存储设计:<ul><li>方案一: 指针域的个数等于树的度, 对于树中各节点度相差很大时, 比较浪费空间<ul><li>data为数据域, child1~childd为指针域</li></ul></li><li>方案二: 每个结点指针域的个数等于该结点的度, 专门取一个位置来存储结点指针域的个数<ul><li>data为指针域, degree为度域, child1~childd为指针域</li></ul></li></ul></li></ul></li><li>概念:<ul><li>把每个结点的孩子结点排列起来, 以单链表做存储结构, 则n个结点有n个孩子链表, 如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表, 采用顺序存储结构, 存放一个一维数组中</li></ul></li></ul><h4 id=结构>结构:
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><ul><li>孩子链表的孩子结点:<ul><li>child为数据域,存储某个结点在表头数组中的下标;</li><li>next为指针域, 存储指向某结点的下一个孩子结点的指针</li></ul></li><li>表头数组的表头结点:<ul><li>data为数据域,存储某结点的数据信息;</li><li>firstchild为头指针域,存储该节点的孩子链表的头指针</li></ul></li></ul><h4 id=扩展>扩展
<a class=header-anchor href=#%e6%89%a9%e5%b1%95></a></h4><ul><li>双亲孩子表示法</li></ul><h3 id=孩子兄弟表示法>孩子兄弟表示法
<a class=header-anchor href=#%e5%ad%a9%e5%ad%90%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95></a></h3><ul><li>data为数据域, firstchild为指针域, 储存该结点的第一个孩子结点的储存地址, rightsib为指针域, 存储该节点的右兄弟结点的存储地址</li></ul><h2 id=二叉树binary-tree>二叉树(Binary Tree)
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91binary-tree></a></h2><ul><li>概念: 是n(n>=0)个结点的有限集合,该集合或者为空集(称为空二叉树), 或者由一个根节点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成</li><li>特点:<ul><li>每个结点最多有两课子树, 即不存在度大于2的结点, 没有子树或者有一棵子树均可</li><li>左子树和右子树是有序的</li><li>即使某结点只有一棵子树, 也要区分是左子树还是右子树</li></ul></li><li>基本形态(5种):<ul><li>空二叉树</li><li>只有一个根节点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树</li></ul></li></ul><h3 id=特殊二叉树>特殊二叉树
<a class=header-anchor href=#%e7%89%b9%e6%ae%8a%e4%ba%8c%e5%8f%89%e6%a0%91></a></h3><ul><li>斜树: 左斜树和右斜树<ul><li>每层只有一个结点, 结点数与二叉树的深度相同</li></ul></li><li>满二叉树: 所有分支节点都存在左子树和右子树, 并且所有叶子都在同一层上</li></ul><h4 id=完全二叉树>完全二叉树:
<a class=header-anchor href=#%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91></a></h4><ul><li>概念:<ul><li>对一颗具有n个结点的二叉树按层次编号, 如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同, 则这课二叉树称为完全二叉树</li></ul></li><li>特点:<ul><li>叶子结点只能出现在最下两层</li><li>最下层的叶子一定集中在左部连续位置</li><li>倒数第二层,若有叶子结点,一定都在右部连续位置</li><li>如果结点度为1, 则该结点只有左子树, 不存在右子树</li><li>同样结点的二叉树,完全二叉树的深度最小</li></ul></li></ul><h3 id=二叉树的性质>二叉树的性质
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8></a></h3><h4 id=性质一>性质一:
<a class=header-anchor href=#%e6%80%a7%e8%b4%a8%e4%b8%80></a></h4><ul><li>在二叉树的第i层上至多有2^(i-1)个结点(i>=1)</li></ul><h4 id=性质二>性质二:
<a class=header-anchor href=#%e6%80%a7%e8%b4%a8%e4%ba%8c></a></h4><ul><li>深度为k的二叉树至多有2^k - 1 个结点</li></ul><h4 id=性质三>性质三:
<a class=header-anchor href=#%e6%80%a7%e8%b4%a8%e4%b8%89></a></h4><ul><li>对任何一棵二叉树T, 如果其终端结点数为n0, 度为2的结点数为n2, 则n0 = n2 + 1</li></ul><h4 id=性质四>性质四:
<a class=header-anchor href=#%e6%80%a7%e8%b4%a8%e5%9b%9b></a></h4><ul><li>具有n个结点的完全二叉树的深度为[log2n] + 1 ([x]表示不大于x的最大整数)</li></ul><h4 id=性质五>性质五:
<a class=header-anchor href=#%e6%80%a7%e8%b4%a8%e4%ba%94></a></h4><ul><li>对于一棵有n个结点的完全二叉树(其深度为[log2n] + 1)的结点按层序编号(从第1层到第[log2n] + 1层, 每层从左到右), 对任一节点i(1&lt;=i&lt;=n):<ul><li>如果i=1, 则结点i是二叉树的根, 无双亲; 如果i>1, 则其双亲是结点[i/2]</li><li>如果2i>n, 则结点i无左孩子(结点i为叶子结点); 否则其孩子是结点2i</li><li>如果2i+1>n, 则结点i无右孩子; 否则其右孩子是结点2i+1</li></ul></li></ul><h3 id=二叉树的存储结构>二叉树的存储结构
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84></a></h3><h4 id=二叉树顺序存储结构>二叉树顺序存储结构
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84></a></h4><ul><li>用一维数组存储二叉树中的结点</li><li>一般只用于存储完全二叉树</li></ul><h4 id=二叉链表>二叉链表
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e9%93%be%e8%a1%a8></a></h4><ul><li>二叉树每个结点最多有两个孩子, 所以为它设计一个数据域和两个指针域, 我们称这样的链表叫做二叉链表</li><li>如有需要可以增加一个指向其双亲的指针域, 称之为三叉链表</li></ul><h3 id=遍历二叉树>遍历二叉树
<a class=header-anchor href=#%e9%81%8d%e5%8e%86%e4%ba%8c%e5%8f%89%e6%a0%91></a></h3><ul><li>二叉树额遍历(traversing binary tree):<ul><li>从根节点出发, 按照某种次序依次访问二叉树所有结点, 使得每个结点被访问一次, 且仅被访问一次</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>        A
</span></span><span style=display:flex><span>     /     \
</span></span><span style=display:flex><span>    B       C
</span></span><span style=display:flex><span>   / \     / \
</span></span><span style=display:flex><span>  D   E   F   G
</span></span><span style=display:flex><span> /       /     \
</span></span><span style=display:flex><span>H       I       J
</span></span><span style=display:flex><span> \
</span></span><span style=display:flex><span>  K
</span></span></code></pre></div><ul><li>二叉树遍历方法: 把树中的结点变成某种意义的线性序列<ol><li>前序遍历: 先访问根节点, 然后前序遍历左子树, 再前序遍历右子树</li><li>中序遍历: 中序遍历根节点的左子树, 然后访问根节点, 最后中序遍历右子树</li><li>后序遍历: 从左到右, 先叶子后结点的方式遍历访问左右子树, 最后访问根节点</li><li>层序遍历: 同一层按从左到右的顺序对结点逐个访问</li></ol></li></ul><h4 id=前序遍历递归算法>前序遍历递归算法
<a class=header-anchor href=#%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95></a></h4><ul><li>示例:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PreOrderTraverse</span>(BiTree T)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(T <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, T<span style=color:#f92672>-&gt;</span>data); <span style=color:#75715e>//显示结点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>PreOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>lchild);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PreOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>rchild);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>遍历顺序: ABDHKECFIGJ</li></ul><h4 id=中序遍历递归算法684>中序遍历递归算法(6.8.4)
<a class=header-anchor href=#%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95684></a></h4><ul><li>示例:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InOrderTraverse</span>(BiTree T)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(T <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>InOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>lchild); <span style=color:#75715e>//中序遍历左子树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, T<span style=color:#f92672>-&gt;</span>data); <span style=color:#75715e>//显示结点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>InOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>rchild);	<span style=color:#75715e>//中序遍历右子树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>遍历顺序: HKDBEAIFCGJ</li></ul><h4 id=后序遍历递归算法>后序遍历递归算法
<a class=header-anchor href=#%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95></a></h4><ul><li>示例:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PostOrderTraverse</span>(BiTree T)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(T <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PostOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>lchild);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PostOrderTraverse</span>(T<span style=color:#f92672>-&gt;</span>rchild);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, T<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>遍历顺序: KHDEBIFJGCA</li></ul><h4 id=遍历总结>遍历总结
<a class=header-anchor href=#%e9%81%8d%e5%8e%86%e6%80%bb%e7%bb%93></a></h4><ul><li>总结:<ul><li>遍历都是从根节点开始</li><li>前序遍历是先打印再递归左右</li></ul></li></ul><h4 id=遍历性质>遍历性质
<a class=header-anchor href=#%e9%81%8d%e5%8e%86%e6%80%a7%e8%b4%a8></a></h4><ul><li>已知前序遍历序列和中序遍历序列, 可以唯一确定一棵二叉树</li><li>已知后序遍历序列和中序遍历序列, 可以唯一确定一棵二叉树</li></ul><h3 id=二叉树的建立>二叉树的建立
<a class=header-anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%bb%ba%e7%ab%8b></a></h3><ul><li>利用递归原理, 在原来应该打印结点的地方, 改成生成结点, 给结点赋值操作</li></ul><h3 id=线索二叉树threaded-binary-tree>线索二叉树(Threaded Binary Tree)
<a class=header-anchor href=#%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91threaded-binary-tree></a></h3><ul><li>引入: n个节点的二叉树存在n+1个空指针域</li><li>定义:<ul><li>指向前驱和后继的指针称为线索, 加上线索的二叉链表称为线索链表, 相应的二叉树称为线索二叉树</li></ul></li><li>特征: 其实线索二叉树, 等于把一棵二叉树转变成了一个双向链表</li><li>线索化: 在遍历的过程中修改空指针的过程</li></ul><h4 id=使用场景>使用场景
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af></a></h4><ul><li>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继, 那么可以采用线索二叉链表的存储结构</li></ul><h2 id=霍夫曼树huffman-tree>霍夫曼树(Huffman Tree)
<a class=header-anchor href=#%e9%9c%8d%e5%a4%ab%e6%9b%bc%e6%a0%91huffman-tree></a></h2><ul><li>相关概念:<ul><li>路径长度:<ul><li>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径, 路径上的分支数目称做路径长度</li></ul></li><li>树的路径长度:<ul><li>从树根到每一结点的路径长度之和</li></ul></li></ul></li><li>定义:<ul><li>假设有n个权值{w1,w2,&mldr;,wn}, 构造一棵有n个叶子结点的二叉树, 每个叶子结点带权wk, 每个叶子的路径长度为lk, 我们通常记作, 其中带权路径长度WPL最小的二叉树称做霍夫曼树</li></ul></li></ul><h3 id=算法描述>算法描述
<a class=header-anchor href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0></a></h3><ol><li>根据给定n个权值{w1,w2,&mldr;,wn}构成n课二叉树的集合F={T1,T2,&mldr;,Tn}, 其中每颗二叉树Ti中只有一个带权为wi根节点, 其左右子树均为空</li><li>在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树, 且置新的二叉树的根节点的权值为其左右子树上根节点的权值之和</li><li>在F中删除这两棵树, 同时将新得到的二叉树加入F中</li><li>重复2和3步骤, 直到F只含一棵树为止。这棵树便是霍夫曼树</li></ol><h3 id=霍夫曼编码>霍夫曼编码
<a class=header-anchor href=#%e9%9c%8d%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81></a></h3><ul><li>构造霍夫曼树主要运用于编码，称为霍夫曼编码。</li><li>定义：<ul><li>一般地，设需要编码的字符集为{d1,d2,&mldr;,dn}, 各个字符在电文中出现的次数或频率的集合为{w1,w2,&mldr;,wn}, 以d1,d2,&mldr;,dn作为叶子结点, 以w1,w2,&mldr;,wn作为相应叶子结点的权值来构造一棵霍夫曼树。规定霍夫曼树的左分支代表0，右分支代表1，则从根节点到叶子结点所经过的路径分支组成0和1的序列便为该节点对应字符的编码，即为霍夫曼编码。</li></ul></li><li>霍夫曼编码实现过程中运用到了贪心算法。霍夫曼树中权值越大的结点距离根结点越近。采用二叉树可以适当降低编码长度，尤其是在编码长度较长，且权值分布不均匀时，采用霍夫曼编码可以大大缩短编码长度。</li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>数据结构</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
数据结构基础之树</li><li class=post-copyright-author><strong>本文作者： </strong>Patrick</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/tree-of-datastructure/ title=数据结构基础之树>/post/tree-of-datastructure/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/graph-of-datastructure/ rel=next title=数据结构基础之图><i class="fa fa-chevron-left"></i> 数据结构基础之图</a></div><div class="post-nav-prev post-nav-item"><a href=/post/linerlist-of-datastructure/ rel=prev title=数据结构之线性表>数据结构之线性表
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2015 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Patrick</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.121.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.bootcdn.net/ajax/libs/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"bootcdn","router":"https://cdn.bootcdn.net/ajax/libs"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0c78e5a4df586ee46d02716ffa91a4a322e56763e04e91eb2ba052c9469ed02.js defer></script><script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>