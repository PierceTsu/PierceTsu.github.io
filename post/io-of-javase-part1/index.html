<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.121.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Java基础之IO操作（上）"><meta itemprop=description content="io-of-javase-part1"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/img/avatar.jpg"><meta itemprop=keywords content="Java"><meta property="og:type" content="article"><meta property="og:title" content="Java基础之IO操作（上）"><meta property="og:description" content="io-of-javase-part1"><meta property="og:image" content="/img/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/io-of-javase-part1/"><meta property="og:site_name" content="Patrick's Blog"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Patrick"><meta property="article:published_time" content="2015-06-06 17:39:02 +0800 CST"><meta property="article:modified_time" content="2024-03-17 17:39:02 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.a987c3fbca3727259a25c99140afed885cbffe7b77dba717d89bbe0780afcd01.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"css":{"file":"dist/katex.min.css","name":"katex","version":"0.16.0"},"js":[{"file":"dist/katex.min.js","name":"katex","version":"0.16.0"},{"alias_name":"katex","file":"dist/contrib/auto-render.min.js","name":"auto-render","version":"0.16.0"}],"render":"katex"},"path":"io-of-javase-part1","permalink":"/post/io-of-javase-part1/","title":"Java基础之IO操作（上）","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Java基础之IO操作（上） - Patrick's Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Patrick's Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Once start, goes forward!</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>33</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#io流>IO流</a><ul><li><a href=#概述>概述：</a></li><li><a href=#分类按操作数据>分类(按操作数据)：</a></li></ul></li><li><a href=#字符流>字符流</a><ul><li><a href=#字符流两个基类>字符流两个基类：</a><ul><li><a href=#字符流中的输出流writer>字符流中的输出流：Writer</a></li><li><a href=#字符流中的输入流reader>字符流中的输入流：Reader</a></li></ul></li><li><a href=#字符流的缓冲区>字符流的缓冲区</a><ul><li><a href=#对应类2种>对应类（2种）:</a></li></ul></li></ul></li><li><a href=#字节流>字节流</a><ul><li><a href=#分类>分类：</a></li><li><a href=#字节输入流inputstream>字节输入流InputStream</a></li><li><a href=#字节输出流outputstream>字节输出流OutputStream</a></li><li><a href=#转换流>转换流</a><ul><li><a href=#键盘录入最常见方法>键盘录入最常见方法：</a></li></ul></li><li><a href=#字节流的缓冲区>字节流的缓冲区</a></li></ul></li><li><a href=#流操作的基本规律>流操作的基本规律</a><ul><li><a href=#通过三个明确来完成>通过三个明确来完成。</a></li></ul></li><li><a href=#file类>File类</a><ul><li><a href=#概述-1>概述：</a></li><li><a href=#常见方法>常见方法：</a><ul><li><a href=#构造方法>构造方法</a></li><li><a href=#常用方法>常用方法：</a></li><li><a href=#代码示例>代码示例：</a></li></ul></li><li><a href=#递归>递归</a><ul><li><a href=#简介>简介：</a></li><li><a href=#使用时机>使用时机：</a></li><li><a href=#注意>注意:</a></li><li><a href=#代码示例-1>代码示例：</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Patrick src=/imgs/img-lazy-loading.gif data-src=/img/avatar.jpg><p class=site-author-name itemprop=name>Patrick</p><div class=site-description itemprop=description>个人学习笔记</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>33</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>8</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2015-04-05T13:57:58+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=22332></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=121></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-05-31T21:26:21+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/io-of-javase-part1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/img/avatar.jpg"><meta itemprop=name content="Patrick"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Patrick"><meta itemprop=description content="个人学习笔记"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Java基础之IO操作（上）"><meta itemprop=description content="io-of-javase-part1"></span><header class=post-header><h1 class=post-title itemprop="name headline">Java基础之IO操作（上）
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/io-of-javase-part1.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2015-06-06 17:39:02 +0800 CST" itemprop="dateCreated datePublished" datetime="2015-06-06 17:39:02 +0800 CST">2015-06-06
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-03-17T17:39:02+08:00 itemprop=dateModified datetime=2024-03-17T17:39:02+08:00>2024-03-17</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80 itemprop=url rel=index><span itemprop=name>编程语言</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>1063</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>5分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/io-of-javase-part1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=io流>IO流
<a class=header-anchor href=#io%e6%b5%81></a></h2><h3 id=概述>概述：
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0></a></h3><ul><li>用来处理设备之间的数据传输。Java对数据的操作是通过流的方式。Java用于操作流的对象都在IO包中。</li></ul><h3 id=分类按操作数据>分类(按操作数据)：
<a class=header-anchor href=#%e5%88%86%e7%b1%bb%e6%8c%89%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae></a></h3><ul><li>字符流的抽象基类：<ul><li>Reader<ul><li>BuffedReader(字符读取流缓冲区)</li><li>InputStreamReader（转换流）<ul><li>FileReader</li></ul></li></ul></li><li>Writer<ul><li>PrintWrite</li><li>BuffedWriter(字符输出流缓冲区)</li><li>OutputStreamWriter（转换流）<ul><li>FileWriter</li></ul></li></ul></li></ul></li></ul><ul><li><p>字节流的抽象基类：</p><ul><li><p>InputStream</p><ul><li>PipedInputStream（管道流）</li><li>ObjectInputStream(对象流)</li><li>SequenceInputStream（合并流）</li><li>FileInputStream</li><li>FilterInputStream<ul><li>BufferedInputStream(字节读取流缓冲区)</li></ul></li></ul></li><li><p>OutputStream</p><ul><li>PipedOutputStream（管道流）</li><li>ObjectOutputStream(对象流)</li><li>FileOutputStream</li><li>FilterOutputStream<ul><li>BufferedOutputStream(字节输出流缓冲区)</li><li>PrintStream</li></ul></li></ul></li></ul></li><li><p>特点：四个类派生出来的子类名称都是以其父类名作为子类名的后缀</p></li></ul><h2 id=字符流>字符流
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e6%b5%81></a></h2><p>字节流+编码表</p><h3 id=字符流两个基类>字符流两个基类：
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e6%b5%81%e4%b8%a4%e4%b8%aa%e5%9f%ba%e7%b1%bb></a></h3><h4 id=字符流中的输出流writer>字符流中的输出流：Writer
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e6%b5%81%e4%b8%ad%e7%9a%84%e8%be%93%e5%87%ba%e6%b5%81writer></a></h4><ul><li><p>继承体系：</p><ul><li>Writer<ul><li>PrintWrite</li><li>BuffedWriter(字符输出流缓冲区)</li><li>OutputStreamWriter（转换流）<ul><li>FileWriter</li></ul></li></ul></li></ul></li><li><p>特点：文件不存在，则会自动创建；如果文件存在，则会被覆盖</p></li><li><p>基本方法：</p><ul><li>void write(char[] cbuf) 写入字符数组。</li><li>abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。</li><li>void write(String str) 写入字符串。</li><li>void write(String str, int off, int len) 写入字符串的某一部分。</li></ul></li><li><p>步骤：</p><ul><li>创建一个可以往文件中写入字符数据的字符输出流对象</li><li>调用Writer对象中的write方法，写入数据，数据被写入到临时存储缓冲区中</li><li>进行刷新，将数据直接写入到目的地中</li><li>关闭流，关闭资源，在关闭前会先调用flush刷新缓冲中的数据到目的地</li></ul></li><li><p>说明：</p><ul><li>close方法只能用一次。流关闭以后不能再调用write方法；</li><li>如果<strong>构造函数中加入true</strong>，代表不覆盖已有的文件，可以实现对<strong>文件进行续写</strong>。</li></ul></li><li><p>IO流的异常处理方式：为防止代码异常导致流无法关闭，因此在finally中对流进行关闭。</p><ul><li>代码示例：</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>FileWriter fw <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>	fw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileWriter(<span style=color:#e6db74>&#34;demo.txt&#34;</span>);
</span></span><span style=display:flex><span>	fw.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;abcdefg&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>	System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(fw<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>			fw.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;关闭失败&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h4 id=字符流中的输入流reader>字符流中的输入流：Reader
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e6%b5%81%e4%b8%ad%e7%9a%84%e8%be%93%e5%85%a5%e6%b5%81reader></a></h4><ul><li><p>继承体系：</p><ul><li>Reader<ul><li>BuffedReader(字符读取流缓冲区)</li><li>InputStreamReader（转换流）<ul><li>FileReader</li></ul></li></ul></li></ul></li><li><p>特点：最后带Reader的均为其子类</p></li><li><p>基本方法：</p><ul><li>int read() 读取单个字符，而且会自动往下读；返回作为整数读取的字符，范围在 0 到 65535 之间 (0x00*0xffff)，如果已到达流的末尾，则返回 <code>*1</code></li><li>int read(char[] cbuf) 将字符读入数组。返回：读取的字符个数（数组长度），如果已到达流的末尾，则返回 <code>*1</code></li><li>abstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。</li><li>int read(CharBuffer target) 试图将字符读入指定的字符缓冲区。</li></ul></li><li><p>步骤：</p><ul><li>创建一个文件读取流对象，和指定名称的文件相关联（要保证该文件是已经存在的，如果不存在，会发生异常FileNotFoundException）</li><li>调用读取流对象的read方法</li><li>关闭流，关闭资源</li></ul></li></ul><h3 id=字符流的缓冲区>字符流的缓冲区
<a class=header-anchor href=#%e5%ad%97%e7%ac%a6%e6%b5%81%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba></a></h3><ul><li>概述：<ul><li>缓冲区的出现提高了对数据的读写效率</li><li>缓冲区要结合流才可以使用</li></ul></li><li>作用：<ul><li>提高了对数据的读写效率</li><li>在流的基础上对流的功能进行了增强<ul><li>写入换行:使用BufferedWriter类中的 <strong>newLine()</strong> 方法;</li><li>读取一行数据:使用BufferedReader类中的 <strong>readLine()</strong> 方法</li></ul></li></ul></li></ul><h4 id=对应类2种>对应类（2种）:
<a class=header-anchor href=#%e5%af%b9%e5%ba%94%e7%b1%bb2%e7%a7%8d></a></h4><ul><li><p><strong>字符读取流缓冲区</strong>: BufferedReader</p><ul><li>基本方法：<ul><li>BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。</li><li>int read() 读取单个字符。 覆盖了父类中的read方法。</li><li>String readLine() 读取一个文本行。读到文件末尾时，返回null。可采用返回是否为null作为循环条件。</li></ul><blockquote><p>特点：使用了读取缓冲区的read方法，将读取到的字符进行缓冲并判断换行标记，将标记前的缓冲数据变成字符串返回。</p></blockquote></li></ul></li><li><p>代码示例：</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	明白了BufferedReader类中特有方法readerLine的原理后，
</span></span></span><span style=display:flex><span><span style=color:#75715e>	可以自定义一个类中包含一个功能和readLine一致的方法。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	来模拟一下BufferedReader
</span></span></span><span style=display:flex><span><span style=color:#75715e>	*/</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.*;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyBufferedReader</span> <span style=color:#66d9ef>extends</span> Reader{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>private</span> Reader r;
</span></span><span style=display:flex><span>		MyBufferedReader(Reader r) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>r</span> <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//可以一次读一行数据的方法。</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>myReadLine</span>() <span style=color:#66d9ef>throws</span> IOException{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//定义一个临时容器。原BufferedReader封装的是字符数组。</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//为了演示方便。定义一个StringBuilder容器，因为最终还是要将数据变成字符串。</span>
</span></span><span style=display:flex><span>			StringBuilder sb <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>int</span> ch <span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>	 		<span style=color:#66d9ef>while</span> ((ch<span style=color:#f92672>=</span>r.<span style=color:#a6e22e>read</span>())<span style=color:#f92672>!=*</span>1) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span>(ch<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;\r&#39;</span>)<span style=color:#75715e>//跳过\r</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span>(ch<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> sb.<span style=color:#a6e22e>toString</span>();<span style=color:#75715e>//通过回车符来标识每一行的数据返回；若文件的最后一行没有回车符，该行将不会返回，因此需在循环结束时，增加判断语句。</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>					sb.<span style=color:#a6e22e>append</span>((<span style=color:#66d9ef>char</span>)ch);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(sb.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>!=</span>0)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> sb.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>		覆盖Reader类中的抽象方法
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>read</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> cbuf,<span style=color:#66d9ef>int</span> off, <span style=color:#66d9ef>int</span> len) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> r.<span style=color:#a6e22e>read</span>(cbuf,off,len);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span>()<span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>			r.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myClose</span>()<span style=color:#66d9ef>throws</span> IOException{
</span></span><span style=display:flex><span>			r.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyBufferedReaderDemo</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException{
</span></span><span style=display:flex><span>			FileReader fr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileReader(<span style=color:#e6db74>&#34;buf.txt&#34;</span>);
</span></span><span style=display:flex><span>			MyBufferedReader myBuf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyBufferedReader(fr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			String line <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>while</span> ((line<span style=color:#f92672>=</span>myBuf.<span style=color:#a6e22e>myReadLine</span>())<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>				System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(line);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			myBuf.<span style=color:#a6e22e>myClose</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><ul><li><p><strong>LineNumberReader</strong> 类：BufferedReader的子类。跟踪行号的缓冲字符输入流。</p><ul><li>此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。</li></ul></li><li><p><strong>字符输出流缓冲区</strong>:BufferedWriter</p><ul><li>基本方法：<ul><li>BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流</li><li>void newLine() 写入一个行分隔符。</li><li>void flush() 刷新该流的缓冲。</li></ul></li></ul></li></ul><h2 id=字节流>字节流
<a class=header-anchor href=#%e5%ad%97%e8%8a%82%e6%b5%81></a></h2><p>基本操作与字符流类相同。但它不仅可以操作字符，还可以操作其他媒体文件。</p><h3 id=分类>分类：
<a class=header-anchor href=#%e5%88%86%e7%b1%bb></a></h3><ul><li>字节流两个基类：<ul><li><p>InputStream</p><ul><li>ByteArrayInputStream</li><li>SequenceInputStream</li><li><strong>FileInputStream</strong></li><li>FilterInputStream<ul><li>DataInputStream</li><li>BufferedInputStream(字节读取流缓冲区)</li></ul></li></ul></li><li><p>OutputStream</p><ul><li>ByteArrayOutputStream</li><li><strong>FileOutputStream</strong></li><li>FilterOutputStream<ul><li>DataOutputStream</li><li>BufferedOutputStream(字节读输出流缓冲区)</li><li>PrintStream</li></ul></li></ul></li></ul></li></ul><h3 id=字节输入流inputstream>字节输入流InputStream
<a class=header-anchor href=#%e5%ad%97%e8%8a%82%e8%be%93%e5%85%a5%e6%b5%81inputstream></a></h3><ul><li>常用方法：<ul><li>int available() 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。</li></ul></li><li>三种读取方法示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#75715e>//读取方式一</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readFile_1</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>		<span style=color:#75715e>//创建一个读取流对象，和指定文件关联</span>
</span></span><span style=display:flex><span>		FileInputStream fis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;fos.txt&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//打印刚好字符字节大小，不过要少用，当文件太大时，可能内存溢出</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> buf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>fis.<span style=color:#a6e22e>available</span>()<span style=color:#f92672>]</span>;<span style=color:#75715e>//定义一个刚刚好的缓冲区，不用再循环了</span>
</span></span><span style=display:flex><span>		fis.<span style=color:#a6e22e>read</span>(buf);
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> String(buf));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fis.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//读取方式二</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readFile_2</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>		FileInputStream fis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;fos.txt&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>//建议使用这种方式</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> buf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>1024<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> ((len<span style=color:#f92672>=</span>fis.<span style=color:#a6e22e>read</span>(buf))<span style=color:#f92672>!=*</span>1) {
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> String(buf,0,len));
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fis.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//读取方式三</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readFile_3</span>() <span style=color:#66d9ef>throws</span> IOException{
</span></span><span style=display:flex><span>		FileInputStream fis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;fos.txt&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>//一次读取一个字节</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> ch <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> ((ch<span style=color:#f92672>=</span>fis.<span style=color:#a6e22e>read</span>())<span style=color:#f92672>!=*</span>1) {
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>((<span style=color:#66d9ef>char</span>)ch);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fis.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h3 id=字节输出流outputstream>字节输出流OutputStream
<a class=header-anchor href=#%e5%ad%97%e8%8a%82%e8%be%93%e5%87%ba%e6%b5%81outputstream></a></h3><ul><li>常用方法：与字符输出流基本相同</li></ul><h3 id=转换流>转换流
<a class=header-anchor href=#%e8%bd%ac%e6%8d%a2%e6%b5%81></a></h3><ul><li><p>概述：字符流与字节流之间的桥梁，方便了字符流与字节流之间的操作</p></li><li><p>应用：字节流中的数据都是字符时，转成字符流操作更高效。</p><ul><li><strong>InputStreamReader</strong>：字节**>字符的桥梁，解码。<ul><li>通过构造方法：InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。</li></ul></li><li><strong>OutputStreamWriter</strong>：字符**>字节的桥梁，编码。<ul><li>通过构造方法：OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。</li><li>OutputStreamWriter(OutputStream out, String charsetName) <strong>创建使用指定字符集的 OutputStreamWriter</strong>。可使用指定的编码将要写入流中的字符编码成字节。<blockquote><p><strong>注：</strong><code>FileWriter fw = new FileWriter("a.txt");</code>等同<code>OutputStreamWriter osw = new OutputStreamWriter(newFileOutputStream("a.txt"),"GBK");</code>其实就是转换流指定了本机默认码表的体现，而且这个转换流的子类对象，可以方便操作文本文件。简单说：操作文件的字节流+本机默认的编码表。是按照默认码表来操作文件的便捷类;如果操作文本文件需要明确具体的码表必须用转换流。</p></blockquote></li></ul></li></ul></li><li><p>说明:使用字节流读取一个中文字符需要读取两次，因为一个中文字符由两个字节组成，而使用字符流只需读取一次。</p></li></ul><h4 id=键盘录入最常见方法>键盘录入最常见方法：
<a class=header-anchor href=#%e9%94%ae%e7%9b%98%e5%bd%95%e5%85%a5%e6%9c%80%e5%b8%b8%e8%a7%81%e6%96%b9%e6%b3%95></a></h4><ul><li>步骤：<ul><li>获取键盘录入对象：<code>InputStream in = System.in;</code></li><li>将字节流对象转换成字符流对象：<code>InputStreamReader isr = new InputStreamReader(in);</code></li><li>为了提高效率，将字符串进行缓冲区技术高效操作：<code>BufferedReader bufr =new BufferedReader(isr);</code></li></ul></li><li>简写示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>	BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
</span></span><span style=display:flex><span>	BufferedWriter bufw =new BufferedWriter(new OutputStreamWriter(System.out));
</span></span></code></pre></div><h3 id=字节流的缓冲区>字节流的缓冲区
<a class=header-anchor href=#%e5%ad%97%e8%8a%82%e6%b5%81%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba></a></h3><ul><li>同样是为了提高字节流的读写效率</li><li>BufferedInputStream和BufferedOutputStream</li></ul><h2 id=流操作的基本规律>流操作的基本规律
<a class=header-anchor href=#%e6%b5%81%e6%93%8d%e4%bd%9c%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%a7%84%e5%be%8b></a></h2><h3 id=通过三个明确来完成>通过三个明确来完成。
<a class=header-anchor href=#%e9%80%9a%e8%bf%87%e4%b8%89%e4%b8%aa%e6%98%8e%e7%a1%ae%e6%9d%a5%e5%ae%8c%e6%88%90></a></h3><ol><li>明确源和目的。<ul><li>源：输入流(InputStream、Reader)</li><li>目的：输出流（OutputStream、Writer）</li></ul></li><li>操作的数据是否是纯文本。<ul><li>源：<ul><li>是：字符流（Rea der）</li><li>否：字节流（InputStream）</li></ul></li><li>目的：<ul><li>是：字符流（Writer）</li><li>否：字节流（OutputStream）</li></ul></li></ul></li><li>当体系明确后，再明确具体的设备。<ul><li>源设备：<ul><li>硬盘：File</li><li>键盘：System.in</li><li>内存：数组（ArrayStream）</li><li>网络：Socket流</li></ul></li><li>目的设备：<ul><li>硬盘：File</li><li>控制台：System.out</li><li>内存：数组（ArrayStream）</li><li>网络：Socket流</li></ul></li></ul></li><li>是否需要额外功能<ul><li>是否需要高效（缓冲区）<ul><li>是，就加上buffer</li></ul></li></ul></li></ol><ul><li>代码示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.BufferedReader;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.BufferedWriter;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.FileOutputStream;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.InputStreamReader;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.OutputStreamWriter;
</span></span><span style=display:flex><span>	<span style=color:#f92672>import</span> java.io.PrintStream;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 需求：把键盘录入的数据按照指定的编码表（utf*8）,存到文件中。		
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 分析：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		源：键盘（System.in）
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 		目的：FileWriter
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 		
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *  	纯文本 Writer
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 		
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		设备：硬盘，一个文件，使用FileWriter
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		但是FileWriter是使用的默认编码表:GBK,存储时，需要加入指定的编码表，而指定的编码表只有转换流可以指定
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		所以要使用的对象是OutputStreamWriter。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		而该转换流对象需要接收一个字节输出流，而且还可以操作的文件的字节输出流:FileOutputStream
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&#34;d.txt&#34;),&#34;UTF*8&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		需要提高效率吗？需要
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 *		BufferedWriter bufw = new BufferedWriter(osw);
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TransStreamDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 更改源</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// System.setIn(new FileInputStream(&#34;PersonDemo.java&#34;));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 更改目标，将会生成一个空文件（若不存在，存在则会覆盖）</span>
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>setOut</span>(<span style=color:#66d9ef>new</span> PrintStream(<span style=color:#e6db74>&#34;zz.txt&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 键盘录入</span>
</span></span><span style=display:flex><span>			BufferedReader bufr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(
</span></span><span style=display:flex><span>					System.<span style=color:#a6e22e>in</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 按照指定的编码表（utf*8）,将数据存到文件中</span>
</span></span><span style=display:flex><span>			BufferedWriter bufw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedWriter(<span style=color:#66d9ef>new</span> OutputStreamWriter(
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>new</span> FileOutputStream(<span style=color:#e6db74>&#34;d1.txt&#34;</span>), <span style=color:#e6db74>&#34;UTF*8&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			String line <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>while</span> ((line <span style=color:#f92672>=</span> bufr.<span style=color:#a6e22e>readLine</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;over&#34;</span>.<span style=color:#a6e22e>equals</span>(line))
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>				<span style=color:#75715e>// System.out.println(line.toUpperCase());</span>
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>write</span>(line.<span style=color:#a6e22e>toUpperCase</span>());
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>newLine</span>();<span style=color:#75715e>// newLine()为BufferedReader特有方法，跨平台</span>
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			bufr.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=file类>File类
<a class=header-anchor href=#file%e7%b1%bb></a></h2><h3 id=概述-1>概述：
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0-1></a></h3><p>用来将文件或者文件夹封装成对象，方便对文件与文件夹的属性信息进行操作。
File对象可以作为参数传递给流的构造函数。</p><h3 id=常见方法>常见方法：
<a class=header-anchor href=#%e5%b8%b8%e8%a7%81%e6%96%b9%e6%b3%95></a></h3><h4 id=构造方法>构造方法
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95></a></h4><ul><li>File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</li><li>File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</li><li>File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//可以将一个已存在的，或者不存在的文件或者目录封装成file对象，不会创建文件</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//方式一:</span>
</span></span><span style=display:flex><span>File f1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;d:\\demo\\a.txt&#34;</span> );
</span></span><span style=display:flex><span><span style=color:#75715e>//方式二:</span>
</span></span><span style=display:flex><span>File f2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;d:\\demo&#34;</span> ,<span style=color:#e6db74>&#34;a.txt&#34;</span> );
</span></span><span style=display:flex><span><span style=color:#75715e>//方式三:</span>
</span></span><span style=display:flex><span>File f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;d:\\demo&#34;</span> );
</span></span><span style=display:flex><span>File f3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(f,<span style=color:#e6db74>&#34;a.txt&#34;</span> );
</span></span><span style=display:flex><span><span style=color:#75715e>/*考虑到Windows和Linux系统通用（File.separator是与系统有关的默认名称分隔符。
</span></span></span><span style=display:flex><span><span style=color:#75715e>在 UNIX 系统上，此字段的值为 &#39;/&#39;；在 MicrosoftWindows 系统上，它为 &#39;\\&#39;。）:
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>File f4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;d:&#34;</span> <span style=color:#f92672>+</span> File.<span style=color:#a6e22e>separator</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;demo&#34;</span> <span style=color:#f92672>+</span>File.<span style=color:#a6e22e>separator</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;a.txt&#34;</span> );
</span></span></code></pre></div><h4 id=常用方法>常用方法：
<a class=header-anchor href=#%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95></a></h4><ul><li><p>创建:</p><ul><li>boolean createNewFile():在指定位置创建文件，如果该文件已经存在，则不创建，返回false。<strong>和输出流不一样，输出流对象一建立创建文件，而且文件已经存在，会覆盖，输出流如果继续想该文件写入数据，可在构造方法中添加true</strong>。</li><li>boolean mkdir():创建文件夹。</li><li>boolean mkdirs():创建多级文件夹。</li></ul></li><li><p>删除:</p><ul><li>boolean delete()：删除失败返回false。如果文件夹中有文件或者文件正在被使用，则删除不了返回falsel。</li><li>void deleteOnExit();在程序退出时删除指定文件。</li></ul></li><li><p>判断:</p><ul><li>boolean exists() :文件是否存在。</li><li>isFile(): 测试此抽象路径名表示的文件是否是一个标准文件。</li><li>isDirectory(): 测试此抽象路径名表示的文件是否是一个目录。</li><li>isHidden(): 测试此抽象路径名指定的文件是否是一个隐藏文件。</li><li>isAbsolute(): 测试此抽象路径名是否为绝对路径名。</li></ul></li><li><p>获取信息:</p><ul><li>String getName()：返回由此抽象路径名表示的文件或目录的名称。</li><li>String getPath()：将此抽象路径名转换为一个路径名字符串。</li><li>String getParent()：该方法返回的是绝对路径中的父目录。如果获取的是相对路径，返回null。如果相对路径中有上一层目录那么该目录就是返回结果。</li><li>getAbsolutePath()：返回此抽象路径名的绝对路径名字符串。</li><li>long lastModified()：返回此抽象路径名表示的文件最后一次被修改的时间。</li><li>long length()：返回此抽象路径名表示的文件的长度，以字节为单位；如果文件不存在，则返回 0L。如果此路径名表示一个目录，则返回值是不确定的。</li><li>static File[] listRoots()：列出可用的文件系统根。</li><li>long getTotalSpace()： 返回此抽象路径名指定的分区大小。</li><li>long getFreeSpace()： 返回此抽象路径名指定的分区中未分配的字节数。</li><li>long getUsableSpace()： 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</li><li>String[] list() 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。<blockquote><p><strong>注：<strong>该方法的File对象中</strong>封装的必须是目录</strong>，否则会产生NullPointerException，如果访问的是系统级目录也会发生空指针异常；如果目录存在但是没有内容，会返回一个数组，但是长度为0。</p></blockquote></li><li>String[] list(FilenameFilter filter) 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。<blockquote><p>实现步骤：先定义一个类实现FilenameFilter接口，然后复写accept方法（boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中）。</p></blockquote></li><li>File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</li></ul></li><li><p>重命名：</p><ul><li>boolean renameTo(File dest)重新命名此抽象路径名表示的文件。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>//示例：
</span></span><span style=display:flex><span>File f1 = new File(&#34;d:\\code\\day21\\0.mp3&#34; );
</span></span><span style=display:flex><span>File f2 = new File(&#34;d:\\code\\day21\\1.mp3&#34; );
</span></span><span style=display:flex><span>boolean b = f1.renameTo(f2);
</span></span></code></pre></div></li></ul></li></ul><h4 id=代码示例>代码示例：
<a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.File;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.FilenameFilter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 需求：获取指定目录下，任意一个指定类型文件的列表
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 分析：可以使用 String[] list(FilenameFilter filter)方法
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 		自定义一个类，实现FilenameFilter接口，覆盖其accept方法
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileListDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 建立一个指定目录的File对象</span>
</span></span><span style=display:flex><span>		File dir <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;D:\\Java\\Day20&#34;</span>);
</span></span><span style=display:flex><span>		dirList(dir);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dirList</span>(File dir) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 调用传入File对象的list方法，并传入一个自定义文件名过滤器类</span>
</span></span><span style=display:flex><span>		String<span style=color:#f92672>[]</span> dirname <span style=color:#f92672>=</span> dir.<span style=color:#a6e22e>list</span>(<span style=color:#66d9ef>new</span> MyTypeFilter(<span style=color:#e6db74>&#34;.java&#34;</span>));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (String s : dirname) {
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(s);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 自定义文件名过滤器类，并实现FilenameFilter接口，覆盖accept方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTypeFilter</span> <span style=color:#66d9ef>implements</span> FilenameFilter {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> String type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 定义构造器</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyTypeFilter</span>(String type) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> type;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>accept</span>(File dir, String name) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> name.<span style=color:#a6e22e>endsWith</span>(type);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=递归>递归
<a class=header-anchor href=#%e9%80%92%e5%bd%92></a></h3><h4 id=简介>简介：
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b></a></h4><ul><li>函数自身直接或者间接的调用到了自身。</li></ul><h4 id=使用时机>使用时机：
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e6%97%b6%e6%9c%ba></a></h4><ul><li>一个功能在被重复使用，并每次使用时，参与运算的结果和上一次调用有关。这时可以用递归来解决问题。</li></ul><h4 id=注意>注意:
<a class=header-anchor href=#%e6%b3%a8%e6%84%8f></a></h4><ul><li>限定条件,要注意递归的次数，尽量避免内存溢出。</li></ul><h4 id=代码示例-1>代码示例：
<a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b-1></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.BufferedWriter;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.File;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.FileWriter;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.ArrayList;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *需求：
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	将一个指定目录下的java文件的绝对路径，存储到一个文本文件中。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	建立一个java文件列表文件。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *思路：
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	1，对指定的目录进行递归
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	2，获取递归过程所有的java文件路径。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	3，将这些路径存储到集合中。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	4，将集合中的数据写入到一个文件中。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JavaFileListDemo</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 将指定目录封装成对象</span>
</span></span><span style=display:flex><span>		File dir <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;D:\\Java&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 建立集合用于存放路径</span>
</span></span><span style=display:flex><span>		List<span style=color:#f92672>&lt;</span>File<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>File<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 调用自定义获取文件列表方法</span>
</span></span><span style=display:flex><span>		fileToList(dir, list);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// System.out.println(list.size());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		File file <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(dir, <span style=color:#e6db74>&#34;javalist.txt&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 调用自定义将集合数据，写入文件的方法</span>
</span></span><span style=display:flex><span>		writeToFile(list, file.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 自定义获取文件列表方法</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fileToList</span>(File dir, List<span style=color:#f92672>&lt;</span>File<span style=color:#f92672>&gt;</span> list) {
</span></span><span style=display:flex><span>		File<span style=color:#f92672>[]</span> files <span style=color:#f92672>=</span> dir.<span style=color:#a6e22e>listFiles</span>();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (File f : files) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (f.<span style=color:#a6e22e>isDirectory</span>())
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 当路径仍为目录时，进行递归</span>
</span></span><span style=display:flex><span>				fileToList(f, list);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 直到是java文件时，将路径存储到集合中</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (f.<span style=color:#a6e22e>getName</span>().<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.java&#34;</span>))
</span></span><span style=display:flex><span>					list.<span style=color:#a6e22e>add</span>(f);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 定义一个将集合数据，写入文件的方法</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeToFile</span>(List<span style=color:#f92672>&lt;</span>File<span style=color:#f92672>&gt;</span> list, String javaListFile) {
</span></span><span style=display:flex><span>		BufferedWriter bufw <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>			bufw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedWriter(<span style=color:#66d9ef>new</span> FileWriter(javaListFile)); <span style=color:#75715e>// 传入一个用于存放数据的文件字符串名&#34;D:\\Java\\javalist.txt&#34;</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (File f : list) {
</span></span><span style=display:flex><span>				String path <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>getAbsolutePath</span>();
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>write</span>(path);
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>newLine</span>();
</span></span><span style=display:flex><span>				bufw.<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;文件写入失败&#34;</span>);
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (bufw <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>					bufw.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;写入关闭失败&#34;</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/java>Java</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
Java基础之IO操作（上）</li><li class=post-copyright-author><strong>本文作者： </strong>Patrick</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/io-of-javase-part1/ title=Java基础之IO操作（上）>/post/io-of-javase-part1/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/io-of-javase-part2/ rel=next title="Io of Javase Part2"><i class="fa fa-chevron-left"></i> Io of Javase Part2</a></div><div class="post-nav-prev post-nav-item"><a href=/post/collection-of-java-part2/ rel=prev title=java基础之集合（下）>java基础之集合（下）
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2015 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Patrick</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.121.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.bootcdn.net/ajax/libs/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"bootcdn","router":"https://cdn.bootcdn.net/ajax/libs"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0c78e5a4df586ee46d02716ffa91a4a322e56763e04e91eb2ba052c9469ed02.js defer></script><script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>